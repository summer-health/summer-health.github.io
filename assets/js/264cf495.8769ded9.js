"use strict";(self.webpackChunkexternal_blog=self.webpackChunkexternal_blog||[]).push([[2106],{3905:(e,t,o)=>{o.d(t,{Zo:()=>u,kt:()=>h});var n=o(7294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function s(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function i(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):s(s({},t),e)),o},u=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var o=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=p(o),m=r,h=c["".concat(l,".").concat(m)]||c[m]||d[m]||a;return o?n.createElement(h,s(s({ref:t},u),{},{components:o})):n.createElement(h,s({ref:t},u))}));function h(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=o.length,s=new Array(a);s[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[c]="string"==typeof e?e:r,s[1]=i;for(var p=2;p<a;p++)s[p]=o[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,o)}m.displayName="MDXCreateElement"},552:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>p});var n=o(7462),r=(o(7294),o(3905));const a={slug:"storybook-and-hocs-a-beautiful-friendship",title:"Storybook and HOCs a Beautiful Friendship \ud83e\udd1d",description:"How our team combines HOCs and Storybook to build our UI system",authors:["eilinora"],tags:["storybook","hoc","react"],image:"/img/storybook-hocs-header.jpg"},s=void 0,i={permalink:"/blog/storybook-and-hocs-a-beautiful-friendship",source:"@site/blog/2023-11-07-storybook-and-hocs-a-beautiful-friendship/index.md",title:"Storybook and HOCs a Beautiful Friendship \ud83e\udd1d",description:"How our team combines HOCs and Storybook to build our UI system",date:"2023-11-07T00:00:00.000Z",formattedDate:"November 7, 2023",tags:[{label:"storybook",permalink:"/blog/tags/storybook"},{label:"hoc",permalink:"/blog/tags/hoc"},{label:"react",permalink:"/blog/tags/react"}],readingTime:5.27,hasTruncateMarker:!0,authors:[{name:"Lori Hutchek",imageURL:"https://github.com/eilinora.png",key:"eilinora"}],frontMatter:{slug:"storybook-and-hocs-a-beautiful-friendship",title:"Storybook and HOCs a Beautiful Friendship \ud83e\udd1d",description:"How our team combines HOCs and Storybook to build our UI system",authors:["eilinora"],tags:["storybook","hoc","react"],image:"/img/storybook-hocs-header.jpg"},nextItem:{title:"Summer Health Q3 Offsite",permalink:"/blog/company-q3-offsite-sonoma-2023"}},l={authorsImageUrls:[void 0]},p=[{value:"A little history",id:"a-little-history",level:2},{value:"But what about our data?",id:"but-what-about-our-data",level:2},{value:"In walks HOCs",id:"in-walks-hocs",level:2},{value:"But what about Typescript types!?!",id:"but-what-about-typescript-types",level:2},{value:"That&#39;s a wrap!",id:"thats-a-wrap",level:2},{value:"Learn more",id:"learn-more",level:2}],u={toc:p},c="wrapper";function d(e){let{components:t,...a}=e;return(0,r.kt)(c,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"a-little-history"},"A little history"),(0,r.kt)("p",null,"When first building out our website we did like many people do and directly accessed our hooks within components. There's nothing wrong with that but as the site grew, as our components file sizes grew, we realized we were running into a few walls. How can we make our components easier to explore and at the same time make our components smaller with the goal of better re-usability?"),(0,r.kt)("p",null,"Several of us have used Storybook at previous companies, so selecting Storybook felt like a no-brainer. Yes, there are storybook competitors out there but it is still the best component viewer out there. You can learn more about Storybook's robust features here at Why Storybook. Now the question was how we make our components more reusable and separate our business logic from our layout logic."),(0,r.kt)("p",null,"As an engineering team, we were already using custom hooks. If you haven't used them before it is a powerful upgrade provided by hooks which allows you to organize your hooks logic into a separate function to make it more easily reusable."),(0,r.kt)("p",null,"Take this component example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// todo-list.tsx\nimport { useEffect, useState } from 'react';\nimport { List, ListItem, ListItemText } from '@mui/material';\n\nexport interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport const TodoList = (): JSX.Element => {\n  const [todos, setTodos] = useState<Todo[]>([]);\n\n  useEffect(() => {\n    fetch('https://jsonplaceholder.typicode.com/todos')\n      .then((response) => response.json())\n      .then((todos: Todo[]) => setTodos(todos));\n  }, []);\n\n  return (\n    <>\n      <List>\n        {todos.map((todo) => (\n          <ListItem key={todo.id}>\n            <ListItemText\n              primary={todo.text}\n              secondary={todo.completed ? 'Completed' : 'Not Completed'}\n            />\n          </ListItem>\n        ))}\n      </List>\n    </>\n  );\n};\n")),(0,r.kt)("p",null,"There's nothing wrong with this approach. It's the most commonly shown example of how to set up a component with hooks. But what if you have to call the to-do list query from multiple components? Or do you need to massage the data returned from the API for your components? Here's where custom hooks come in handy. We can move our fetch of data into a separate file containing our hook, which helps make our component cleaner and easier to reason through."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { useEffect, useState } from 'react';\nimport type { Todo } from '../components/todo-list';\n\ninterface UseTodoReturn {\n  todos: Todo[];\n}\n\nexport function useTodos(): UseTodoReturn {\n  const [todos, setTodos] = useState<Todo[]>([]);\n\n  useEffect(() => {\n    fetch('https://jsonplaceholder.typicode.com/todos')\n      .then((response) => response.json())\n      .then((todos: Todo[]) => setTodos(todos));\n  }, []);\n\n  return { todos };\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// todo-list.tsx\nimport { List, ListItem, ListItemText } from '@mui/material';\nimport { useTodos } from '../queries/todo-list-query';\n\nexport interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport const TodoList = (): JSX.Element => {\n  const { todos } = useTodos();\n\n  return (\n    <List>\n      {todos.map((todo: Todo) => (\n        <ListItem key={todo.id}>\n          <ListItemText\n            primary={todo.text}\n            secondary={todo.completed ? 'Completed' : 'Not Completed'}\n          />\n        </ListItem>\n      ))}\n    </List>\n  );\n};\n")),(0,r.kt)("p",null,"Now that you have this tidier component. It's time to build your stories!"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Tidier",src:o(9696).Z,width:"480",height:"320"})),(0,r.kt)("h2",{id:"but-what-about-our-data"},"But what about our data?"),(0,r.kt)("p",null,"One of the powerful features of Storybook is its add-ons! Allowing your component to fetch data from your service (or an external one) can be complicated once you take it out of your application. Instead of calling your API from your Storybook application; ideally, we are mocking requests. Mock API Request is a great place to look at mocking data requests for your components. However, we decided to take an alternate route."),(0,r.kt)("h2",{id:"in-walks-hocs"},"In walks HOCs"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Walk in",src:o(3379).Z,width:"480",height:"270"})),(0,r.kt)("p",null,"To quote ChatGPT"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"A Higher-Order Component (HOC) is a design pattern used in React, a popular JavaScript library for building user interfaces. It is not a feature of React itself but rather a pattern that leverages React's composability to enhance component functionality and reusability. HOCs are functions that take one component and return another component with additional props or behavior. They are a powerful tool for code reuse, logic abstraction, and separation of concerns in React applications.")),(0,r.kt)("p",null,"Taking advantage of this design pattern makes for a powerful coupling. Yes, we pulled our fetch for to-do's out into a custom hook. But now we can update our component's props or compose several fetches together isolated to a HOC in our application. Our component now becomes a pure UI component. Allowing it to focus on the work needed to display our component's various use cases."),(0,r.kt)("p",null,"In your component that composes your page together you'll want to now wrap your todo list component with your new HOC."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// page.tsx\nimport { WithTodos } from '../queries/with-todos';\nimport { TodoList } from '../components/todo-list';\n\nconst TodoListWithData = WithTodos(TodoList);\n\nexport const Page = (): JSX.Element => (\n  <>\n    <TodoListWithData />\n  </>\n);\n")),(0,r.kt)("p",null,"Your HOC now has your custom hook call."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// with-todos.tsx\nimport React from 'react';\nimport { useTodos } from '../queries/todo-list';\n\ntype HOCComponentProps<TProps> = Omit<TProps, 'todos'>;\n\nexport function WithTodos<TProps>(\n  Component: React.ComponentType<TProps>,\n): (props: HOCComponentProps<TProps>) => JSX.Element {\n  const ComponentRender = (props: TProps): JSX.Element => {\n    const { todos } = useTodos();\n\n    return <Component {...props} todos={todos} />;\n  };\n  ComponentRender.displayName = `WithTodos(${Component.displayName})`;\n\n  return ComponentRender;\n}\n")),(0,r.kt)("p",null,"And finally your component now expects the todos as a prop."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// todo-list.tsx\nimport { List, ListItem, ListItemText } from '@mui/material';\n\nexport interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport interface TodoListProps {\n  todos: Todo[];\n}\n\nexport const TodoList = ({ todos }: TodoListProps): JSX.Element => (\n  <List>\n    {todos.map((todo: Todo) => (\n      <ListItem key={todo.id}>\n        <ListItemText\n          primary={todo.text}\n          secondary={todo.completed ? 'Completed' : 'Not Completed'}\n        />\n      </ListItem>\n    ))}\n  </List>\n);\n")),(0,r.kt)("h2",{id:"but-what-about-typescript-types"},"But what about Typescript types!?!"),(0,r.kt)("p",null,"If you are trying this out as you read this, you may have run into an issue with typescript compaining that your root TodoListWithData component is missing props. The issue is that typescript is expecting those props from the top of the component tree. So we need to tell typescript that our HOC will handle adding the required props for your component."),(0,r.kt)("p",null,"Here is how we do this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"type HOCComponentProps<TProps> = Omit<TProps, 'todos'>;\n")),(0,r.kt)("h2",{id:"thats-a-wrap"},"That's a wrap!"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Hooray",src:o(5295).Z,width:"480",height:"262"})),(0,r.kt)("p",null,"Using HOCs allows us to separate our business logic easily from our UI. Which in turn, helps us to build pure components to show in our Storybook stories. Read our article on MUI which also discusses how we use Storybook to share our coded design schema with our designers."),(0,r.kt)("h2",{id:"learn-more"},"Learn more"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://javascript.plainenglish.io/replace-react-hocs-with-hooks-401824eb7903"},"Replace React HOCs with Hooks - Is it necessary?")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://javascript.plainenglish.io/modernizing-react-components-with-hocs-b4321169c62"},"Modernizing React Components with HOCs")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://react-typescript-cheatsheet.netlify.app/docs/hoc/full_example/"},"Full HOC Example"))))}d.isMDXComponent=!0},5295:(e,t,o)=>{o.d(t,{Z:()=>n});const n=o.p+"assets/images/celebrate-95a5f887802b11a8a559084deb723e5c.gif"},9696:(e,t,o)=>{o.d(t,{Z:()=>n});const n=o.p+"assets/images/cleanup-76441f40d91c6c387c7b5bedf453857c.gif"},3379:(e,t,o)=>{o.d(t,{Z:()=>n});const n=o.p+"assets/images/slow-walkin-d55b7380a8c2a1edc02fc6f2097ef4c2.gif"}}]);